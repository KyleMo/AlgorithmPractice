{"ast":null,"code":"/*\nimport ListNode from './ListNode.js'\nimport LinkedList from './LinkedList.js'\n\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\n\nconst list1 = new LinkedList(head1)\nconst list2 = new LinkedList(head2)\n\nlist1.add(new ListNode(3))\nlist1.add(new ListNode(4))\n\n*/\nimport LinkedList from \"./LinkedList\";\n\nconst mergeTwoLists = (list1, list2) => {\n  let mergeList = new LinkedList();\n  let currNode1 = list1.head;\n  let currNode2 = list2.head; // if either list reaches the end, then just append the entirety of the other list\n  // what they're the same size?\n  // use the or operator. If one list gets to the end, we can just add the rest of the other list\n\n  console.log('start of the while');\n\n  while (currNode1.next !== null || currNode2.next !== null) {\n    console.log(currNode1 + ' ' + currNode2);\n\n    if (currNode1.val <= currNode2.val) {\n      mergeList.add(currNode1);\n      currNode1 = currNode1.next;\n    } else {\n      mergeList.add(currNode2);\n      currNode2 = currNode2.next;\n    }\n  } // we need to add the last nodes\n\n\n  if (currNode1.val <= currNode2.val) {\n    mergeList.add(currNode1);\n    currNode1 = currNode1.next;\n  } else {\n    mergeList.add(currNode2);\n    currNode2 = currNode2.next;\n  }\n\n  return mergeList.head;\n};\n\nexport default mergeTwoLists;","map":{"version":3,"names":["LinkedList","mergeTwoLists","list1","list2","mergeList","currNode1","head","currNode2","console","log","next","val","add"],"sources":["/Users/kylemonstad/Desktop/dsa/frontend/src/algorithms/mergeTwoSortList.js"],"sourcesContent":["/*\nimport ListNode from './ListNode.js'\nimport LinkedList from './LinkedList.js'\n\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\n\nconst list1 = new LinkedList(head1)\nconst list2 = new LinkedList(head2)\n\nlist1.add(new ListNode(3))\nlist1.add(new ListNode(4))\n\n*/\n\nimport LinkedList from \"./LinkedList\"\n\n\nconst mergeTwoLists = (list1, list2) => {\n\n    let mergeList = new LinkedList()\n\n   \n    let currNode1 = list1.head\n    let currNode2 = list2.head\n\n    // if either list reaches the end, then just append the entirety of the other list\n    // what they're the same size?\n\n    // use the or operator. If one list gets to the end, we can just add the rest of the other list\n    console.log('start of the while')\n    while(currNode1.next !== null || currNode2.next !== null){\n        console.log(currNode1 + ' ' + currNode2)\n\n        if (currNode1.val <= currNode2.val){\n            mergeList.add(currNode1)\n            currNode1 = currNode1.next\n        }\n        else {\n            mergeList.add(currNode2)\n            currNode2 = currNode2.next\n        }\n    \n    }\n    // we need to add the last nodes\n    if (currNode1.val <= currNode2.val){\n        mergeList.add(currNode1)\n        currNode1 = currNode1.next\n    }\n    else {\n        mergeList.add(currNode2)\n        currNode2 = currNode2.next\n    }\n\n    return mergeList.head\n\n}\n\n\n\nexport default mergeTwoLists\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,cAAvB;;AAGA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkB;EAEpC,IAAIC,SAAS,GAAG,IAAIJ,UAAJ,EAAhB;EAGA,IAAIK,SAAS,GAAGH,KAAK,CAACI,IAAtB;EACA,IAAIC,SAAS,GAAGJ,KAAK,CAACG,IAAtB,CANoC,CAQpC;EACA;EAEA;;EACAE,OAAO,CAACC,GAAR,CAAY,oBAAZ;;EACA,OAAMJ,SAAS,CAACK,IAAV,KAAmB,IAAnB,IAA2BH,SAAS,CAACG,IAAV,KAAmB,IAApD,EAAyD;IACrDF,OAAO,CAACC,GAAR,CAAYJ,SAAS,GAAG,GAAZ,GAAkBE,SAA9B;;IAEA,IAAIF,SAAS,CAACM,GAAV,IAAiBJ,SAAS,CAACI,GAA/B,EAAmC;MAC/BP,SAAS,CAACQ,GAAV,CAAcP,SAAd;MACAA,SAAS,GAAGA,SAAS,CAACK,IAAtB;IACH,CAHD,MAIK;MACDN,SAAS,CAACQ,GAAV,CAAcL,SAAd;MACAA,SAAS,GAAGA,SAAS,CAACG,IAAtB;IACH;EAEJ,CAzBmC,CA0BpC;;;EACA,IAAIL,SAAS,CAACM,GAAV,IAAiBJ,SAAS,CAACI,GAA/B,EAAmC;IAC/BP,SAAS,CAACQ,GAAV,CAAcP,SAAd;IACAA,SAAS,GAAGA,SAAS,CAACK,IAAtB;EACH,CAHD,MAIK;IACDN,SAAS,CAACQ,GAAV,CAAcL,SAAd;IACAA,SAAS,GAAGA,SAAS,CAACG,IAAtB;EACH;;EAED,OAAON,SAAS,CAACE,IAAjB;AAEH,CAtCD;;AA0CA,eAAeL,aAAf"},"metadata":{},"sourceType":"module"}