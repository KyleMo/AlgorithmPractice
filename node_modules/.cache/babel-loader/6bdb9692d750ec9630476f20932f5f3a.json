{"ast":null,"code":"/*\nimport ListNode from './ListNode.js'\nimport LinkedList from './LinkedList.js'\n\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\n\nconst list1 = new LinkedList(head1)\nconst list2 = new LinkedList(head2)\n\nlist1.add(new ListNode(3))\nlist1.add(new ListNode(4))\n\n*/\nimport LinkedList from \"./LinkedList\";\n\nconst mergeTwoLists = (list1, list2) => {\n  let mergeList = new LinkedList();\n  let currNode1 = list1.head;\n  let currNode2 = list2.head; // if either list reaches the end, then just append the entirety of the other list\n  // what they're the same size?\n\n  while (currNode1.next !== null && currNode2.next !== null) {\n    if (currNode1 <= currNode2) {\n      mergeList.add(currNode1);\n      currNode1 = currNode1.next;\n    } else {\n      mergeList.add(currNode2);\n      currNode2 = currnode2.next;\n    } // if list1 reaches its end but there is still some of list2\n    // if list2 reach its end ^^^^\n\n  } // going to have to do one final check here for the last elemts \n\n\n  console.log(currNode.val);\n  /*\n    const mergeHead = undefined;\n      // linked list travesal\n    // with each trave\n     while(list1.next !== null && list2.next !== null){\n         list1 = list1.next\n        list2 = list2.next\n    }\n      return mergedHead\n    */\n};\n\nexport default mergeTwoLists;","map":{"version":3,"names":["LinkedList","mergeTwoLists","list1","list2","mergeList","currNode1","head","currNode2","next","add","currnode2","console","log","currNode","val"],"sources":["/Users/kylemonstad/Desktop/dsa/frontend/src/algorithms/mergeTwoSortList.js"],"sourcesContent":["/*\nimport ListNode from './ListNode.js'\nimport LinkedList from './LinkedList.js'\n\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\n\nconst list1 = new LinkedList(head1)\nconst list2 = new LinkedList(head2)\n\nlist1.add(new ListNode(3))\nlist1.add(new ListNode(4))\n\n*/\n\nimport LinkedList from \"./LinkedList\"\n\n\nconst mergeTwoLists = (list1, list2) => {\n\n    let mergeList = new LinkedList\n \n    let currNode1 = list1.head\n    let currNode2 = list2.head\n\n    // if either list reaches the end, then just append the entirety of the other list\n    // what they're the same size?\n    while(currNode1.next !== null && currNode2.next !== null){\n\n        if (currNode1 <= currNode2){\n            mergeList.add(currNode1)\n            currNode1 = currNode1.next\n        }\n        else {\n            mergeList.add(currNode2)\n            currNode2 = currnode2.next\n        }\n        // if list1 reaches its end but there is still some of list2\n        // if list2 reach its end ^^^^\n\n        \n        \n    }\n\n    // going to have to do one final check here for the last elemts \n    console.log(currNode.val)\n\n  /*\n    const mergeHead = undefined;\n \n    // linked list travesal\n    // with each trave\n\n    while(list1.next !== null && list2.next !== null){\n\n        list1 = list1.next\n        list2 = list2.next\n    }\n\n\n    return mergedHead\n    */\n}\n\n\n\nexport default mergeTwoLists\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,cAAvB;;AAGA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkB;EAEpC,IAAIC,SAAS,GAAG,IAAIJ,UAAJ,EAAhB;EAEA,IAAIK,SAAS,GAAGH,KAAK,CAACI,IAAtB;EACA,IAAIC,SAAS,GAAGJ,KAAK,CAACG,IAAtB,CALoC,CAOpC;EACA;;EACA,OAAMD,SAAS,CAACG,IAAV,KAAmB,IAAnB,IAA2BD,SAAS,CAACC,IAAV,KAAmB,IAApD,EAAyD;IAErD,IAAIH,SAAS,IAAIE,SAAjB,EAA2B;MACvBH,SAAS,CAACK,GAAV,CAAcJ,SAAd;MACAA,SAAS,GAAGA,SAAS,CAACG,IAAtB;IACH,CAHD,MAIK;MACDJ,SAAS,CAACK,GAAV,CAAcF,SAAd;MACAA,SAAS,GAAGG,SAAS,CAACF,IAAtB;IACH,CAToD,CAUrD;IACA;;EAIH,CAxBmC,CA0BpC;;;EACAG,OAAO,CAACC,GAAR,CAAYC,QAAQ,CAACC,GAArB;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMC,CA5CD;;AAgDA,eAAeb,aAAf"},"metadata":{},"sourceType":"module"}