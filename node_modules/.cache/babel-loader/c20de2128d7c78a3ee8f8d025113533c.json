{"ast":null,"code":"/*\nimport ListNode from './ListNode.js'\nimport LinkedList from './LinkedList.js'\n\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\n\nconst list1 = new LinkedList(head1)\nconst list2 = new LinkedList(head2)\n\nlist1.add(new ListNode(3))\nlist1.add(new ListNode(4))\n\n*/\nimport LinkedList from \"./LinkedList\";\n\nconst mergeTwoLists = (list1, list2) => {\n  let mergeList = new LinkedList();\n  let currNode1 = list1.head;\n  let currNode2 = list2.head; // if either list reaches the end, then just append the entirety of the other list\n  // what they're the same size?\n  // use the or operator. If one list gets to the end, we can just add the rest of the other list\n\n  while (currNode1.next !== null || currNode2.next !== null) {\n    /*\n    if (currNode1 === undefined && currNode2 !== undefined){\n        mergeList.head = list2.head\n    }\n    */\n    if (currNode1.val <= currNode2.val) {\n      mergeList.add(currNode1);\n      currNode1 = currNode1.next;\n    } else {\n      mergeList.add(currNode2);\n      currNode2 = currNode2.next;\n    }\n  } // we need to add the last nodes\n\n\n  if (currNode1.val <= currNode2.val) {\n    mergeList.add(currNode1);\n    currNode1 = currNode1.next;\n  } else {\n    mergeList.add(currNode2);\n    currNode2 = currNode2.next;\n  }\n\n  return mergeList.head;\n};\n\nexport default mergeTwoLists;","map":{"version":3,"names":["LinkedList","mergeTwoLists","list1","list2","mergeList","currNode1","head","currNode2","next","val","add"],"sources":["/Users/kylemonstad/Desktop/dsa/frontend/src/algorithms/mergeTwoSortList.js"],"sourcesContent":["/*\nimport ListNode from './ListNode.js'\nimport LinkedList from './LinkedList.js'\n\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\n\nconst list1 = new LinkedList(head1)\nconst list2 = new LinkedList(head2)\n\nlist1.add(new ListNode(3))\nlist1.add(new ListNode(4))\n\n*/\n\nimport LinkedList from \"./LinkedList\"\n\n\nconst mergeTwoLists = (list1, list2) => {\n\n    let mergeList = new LinkedList()\n\n   \n    let currNode1 = list1.head\n    let currNode2 = list2.head\n\n    // if either list reaches the end, then just append the entirety of the other list\n    // what they're the same size?\n\n    // use the or operator. If one list gets to the end, we can just add the rest of the other list\n    while(currNode1.next !== null || currNode2.next !== null){\n\n        /*\n        if (currNode1 === undefined && currNode2 !== undefined){\n            mergeList.head = list2.head\n        }\n        */\n\n        if (currNode1.val <= currNode2.val){\n            mergeList.add(currNode1)\n            currNode1 = currNode1.next\n        }\n        else {\n            mergeList.add(currNode2)\n            currNode2 = currNode2.next\n        }\n    \n    }\n    // we need to add the last nodes\n    if (currNode1.val <= currNode2.val){\n        mergeList.add(currNode1)\n        currNode1 = currNode1.next\n    }\n    else {\n        mergeList.add(currNode2)\n        currNode2 = currNode2.next\n    }\n\n    return mergeList.head\n\n}\n\n\n\nexport default mergeTwoLists\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,cAAvB;;AAGA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkB;EAEpC,IAAIC,SAAS,GAAG,IAAIJ,UAAJ,EAAhB;EAGA,IAAIK,SAAS,GAAGH,KAAK,CAACI,IAAtB;EACA,IAAIC,SAAS,GAAGJ,KAAK,CAACG,IAAtB,CANoC,CAQpC;EACA;EAEA;;EACA,OAAMD,SAAS,CAACG,IAAV,KAAmB,IAAnB,IAA2BD,SAAS,CAACC,IAAV,KAAmB,IAApD,EAAyD;IAErD;AACR;AACA;AACA;AACA;IAEQ,IAAIH,SAAS,CAACI,GAAV,IAAiBF,SAAS,CAACE,GAA/B,EAAmC;MAC/BL,SAAS,CAACM,GAAV,CAAcL,SAAd;MACAA,SAAS,GAAGA,SAAS,CAACG,IAAtB;IACH,CAHD,MAIK;MACDJ,SAAS,CAACM,GAAV,CAAcH,SAAd;MACAA,SAAS,GAAGA,SAAS,CAACC,IAAtB;IACH;EAEJ,CA7BmC,CA8BpC;;;EACA,IAAIH,SAAS,CAACI,GAAV,IAAiBF,SAAS,CAACE,GAA/B,EAAmC;IAC/BL,SAAS,CAACM,GAAV,CAAcL,SAAd;IACAA,SAAS,GAAGA,SAAS,CAACG,IAAtB;EACH,CAHD,MAIK;IACDJ,SAAS,CAACM,GAAV,CAAcH,SAAd;IACAA,SAAS,GAAGA,SAAS,CAACC,IAAtB;EACH;;EAED,OAAOJ,SAAS,CAACE,IAAjB;AAEH,CA1CD;;AA8CA,eAAeL,aAAf"},"metadata":{},"sourceType":"module"}